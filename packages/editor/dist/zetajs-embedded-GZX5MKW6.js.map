{"version":3,"sources":["../src/utils/pdf/zetajs-embedded.ts"],"names":[],"mappings":";;;AAUA,IAAI,aAAA,GAA+B,IAAA;AACnC,IAAI,mBAAA,GAAqC,IAAA;AAMlC,IAAM,eAAA,GAAkB,CAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA,yFAAA;AAqlCxB,IAAM,sBAAA,GAAyB,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAA;AAsN/B,SAAS,mBAAA,GAA8B;AAC5C,EAAA,IAAI,CAAC,aAAA,EAAe;AAClB,IAAA,MAAM,IAAA,GAAO,IAAI,IAAA,CAAK,CAAC,eAAe,CAAA,EAAG,EAAE,IAAA,EAAM,wBAAA,EAA0B,CAAA;AAC3E,IAAA,aAAA,GAAgB,GAAA,CAAI,gBAAgB,IAAI,CAAA;AAAA,EAC1C;AACA,EAAA,OAAO,aAAA;AACT;AAMO,SAAS,yBAAA,GAAoC;AAClD,EAAA,IAAI,CAAC,mBAAA,EAAqB;AACxB,IAAA,MAAM,IAAA,GAAO,IAAI,IAAA,CAAK,CAAC,sBAAsB,CAAA,EAAG,EAAE,IAAA,EAAM,wBAAA,EAA0B,CAAA;AAClF,IAAA,mBAAA,GAAsB,GAAA,CAAI,gBAAgB,IAAI,CAAA;AAAA,EAChD;AACA,EAAA,OAAO,mBAAA;AACT;AAMO,SAAS,eAAA,GAAwB;AACtC,EAAA,IAAI,aAAA,EAAe;AACjB,IAAA,GAAA,CAAI,gBAAgB,aAAa,CAAA;AACjC,IAAA,aAAA,GAAgB,IAAA;AAAA,EAClB;AACA,EAAA,IAAI,mBAAA,EAAqB;AACvB,IAAA,GAAA,CAAI,gBAAgB,mBAAmB,CAAA;AACvC,IAAA,mBAAA,GAAsB,IAAA;AAAA,EACxB;AACF","file":"zetajs-embedded-GZX5MKW6.js","sourcesContent":["/**\n * Embedded zetajs helper files\n * \n * These files are bundled directly to avoid requiring users to copy static files.\n * The content is lazy-loaded only when PDF export is first used (~56KB).\n * \n * Source: node_modules/zetajs/source/\n */\n\n// Cache blob URLs after creation\nlet zetaJsBlobUrl: string | null = null;\nlet zetaHelperJsBlobUrl: string | null = null;\n\n/**\n * zeta.js content from zetajs library\n * This file sets up the zetajs API on the Module object\n */\nexport const ZETA_JS_CONTENT = `/* -*- Mode: JS; tab-width: 2; indent-tabs-mode: nil; js-indent-level: 2; fill-column: 100 -*- */\n// SPDX-License-Identifier: MIT\n\n'use strict';\n\nModule.zetajs = new Promise(function (resolve, reject) {\n  Module.zetajs$resolve = function() {\n    // A FinalizationRegistry for zetajs objects that own Embind objects that, in turn, should\n    // be .delete()'d (so that Embind doesn't print any \"Embind found a leaked C++ instance\"\n    // warnings for them); it is tied to Module so it doesn't itself get GC'ed early:\n    Module.uno$zetajs_deleteRegistry = new FinalizationRegistry(function(value) {\n      value.forEach((val) => val.delete());\n    });\n    const getProxyTarget = Symbol('getProxyTarget');\n    const keepAlive = Symbol('keepAlive');\n    function gcWrap(obj) {\n      // Embind has already registered obj at some FinalizationRegistry that prints the\n      // \"Embind found a leaked C++ instance\" warning, which we want to suppress; and if we\n      // registered obj itself also at our deleting FinalizationRegistry, the Embind one might\n      // fire first and still print the warning; so instead wrap obj in a Proxy and register\n      // that:\n      const proxy = new Proxy(obj, {});\n      Module.uno$zetajs_deleteRegistry.register(proxy, [obj]);\n      return proxy\n    }\n    function getEmbindSequenceCtor(componentType) {\n      let typename = componentType.toString();\n      let name = 'uno_Sequence';\n      let n = 1;\n      while (typename.startsWith('[]')) {\n        typename = typename.substr(2);\n        ++n;\n      }\n      if (n !== 1) {\n        name += n;\n      }\n      name += '_' + typename.replace(/ /g, '_').replace(/\\\\./g, '$');\n      return Module[name];\n    };\n    function getTypeDescriptionManager() {\n      const ctx = Module.getUnoComponentContext();\n      const tdmAny = ctx.getValueByName(\n        '/singletons/com.sun.star.reflection.theTypeDescriptionManager');\n      ctx.delete();\n      const val = tdmAny.get();\n      tdmAny.delete();\n      const tdm = Module.uno.com.sun.star.container.XHierarchicalNameAccess.query(val);\n      val.delete();\n      return tdm;\n    };\n    function translateTypeDescription(td) {\n      switch (td.getTypeClass()) {\n      case Module.uno.com.sun.star.uno.TypeClass.VOID:\n        return Module.uno_Type.Void();\n      case Module.uno.com.sun.star.uno.TypeClass.BOOLEAN:\n        return Module.uno_Type.Boolean();\n      case Module.uno.com.sun.star.uno.TypeClass.BYTE:\n        return Module.uno_Type.Byte();\n      case Module.uno.com.sun.star.uno.TypeClass.SHORT:\n        return Module.uno_Type.Short();\n      case Module.uno.com.sun.star.uno.TypeClass.UNSIGNED_SHORT:\n        return Module.uno_Type.UnsignedShort();\n      case Module.uno.com.sun.star.uno.TypeClass.LONG:\n        return Module.uno_Type.Long();\n      case Module.uno.com.sun.star.uno.TypeClass.UNSIGNED_LONG:\n        return Module.uno_Type.UnsignedLong();\n      case Module.uno.com.sun.star.uno.TypeClass.HYPER:\n        return Module.uno_Type.Hyper();\n      case Module.uno.com.sun.star.uno.TypeClass.UNSIGNED_HYPER:\n        return Module.uno_Type.UnsignedHyper();\n      case Module.uno.com.sun.star.uno.TypeClass.FLOAT:\n        return Module.uno_Type.Float();\n      case Module.uno.com.sun.star.uno.TypeClass.DOUBLE:\n        return Module.uno_Type.Double();\n      case Module.uno.com.sun.star.uno.TypeClass.CHAR:\n        return Module.uno_Type.Char();\n      case Module.uno.com.sun.star.uno.TypeClass.STRING:\n        return Module.uno_Type.String();\n      case Module.uno.com.sun.star.uno.TypeClass.TYPE:\n        return Module.uno_Type.Type();\n      case Module.uno.com.sun.star.uno.TypeClass.ANY:\n        return Module.uno_Type.Any();\n      case Module.uno.com.sun.star.uno.TypeClass.SEQUENCE:\n        {\n          const itd = Module.uno.com.sun.star.reflection.XIndirectTypeDescription.query(td);\n          const rtd = itd.getReferencedType();\n          itd.delete();\n          const type = translateTypeDescriptionAndDelete(rtd);\n          try {\n            return Module.uno_Type.Sequence(type);\n          } finally {\n            type.delete();\n          }\n        }\n      case Module.uno.com.sun.star.uno.TypeClass.ENUM:\n        return Module.uno_Type.Enum(td.getName());\n      case Module.uno.com.sun.star.uno.TypeClass.STRUCT:\n        return Module.uno_Type.Struct(td.getName());\n      case Module.uno.com.sun.star.uno.TypeClass.EXCEPTION:\n        return Module.uno_Type.Exception(td.getName());\n      case Module.uno.com.sun.star.uno.TypeClass.INTERFACE:\n        return Module.uno_Type.Interface(td.getName());\n      default:\n        throw new Error(\n          'bad type description ' + td.getName() + ' type class ' + td.getTypeClass());\n      }\n    };\n    function translateTypeDescriptionAndDelete(td) {\n      try {\n        return translateTypeDescription(td);\n      } finally {\n        td.delete();\n      }\n    }\n    function translateToEmbind(obj, type, toDelete) {\n      switch (type.getTypeClass()) {\n      case Module.uno.com.sun.star.uno.TypeClass.ANY:\n          {\n              const {any, owning} = translateToAny(obj, Module.uno_Type.Any());\n              if (owning) {\n                  toDelete.push(any);\n              }\n              return any;\n          }\n      case Module.uno.com.sun.star.uno.TypeClass.SEQUENCE:\n          if (Array.isArray(obj)) {\n              const ctype = type.getSequenceComponentType();\n              const seq = new (getEmbindSequenceCtor(ctype))(\n                  obj.length, Module.uno_Sequence.FromSize);\n              for (let i = 0; i !== obj.length; ++i) {\n                  seq.set(i, translateToEmbind(obj[i], ctype, toDelete));\n              }\n              ctype.delete();\n              toDelete.push(seq);\n              return seq;\n          }\n          break;\n      case Module.uno.com.sun.star.uno.TypeClass.STRUCT:\n      case Module.uno.com.sun.star.uno.TypeClass.EXCEPTION:\n          {\n              const val = {};\n              function walk(td) {\n                  const base = td.getBaseType();\n                  if (base !== null) {\n                      const td = Module.uno.com.sun.star.reflection.XCompoundTypeDescription\n                          .query(base);\n                      base.delete();\n                      walk(td);\n                      td.delete();\n                  }\n                  const types = td.getMemberTypes();\n                  const names = td.getMemberNames();\n                  for (let i = 0; i !== types.size(); ++i) {\n                      const name = names.get(i);\n                      const type = translateTypeDescriptionAndDelete(types.get(i));\n                      val[name] = translateToEmbind(obj[name], type, toDelete);\n                      type.delete();\n                  }\n                  types.delete();\n                  names.delete();\n              };\n              const tdm = getTypeDescriptionManager();\n              const tdAny = tdm.getByHierarchicalName(type.toString());\n              tdm.delete();\n              const ifc = tdAny.get();\n              tdAny.delete();\n              const td = Module.uno.com.sun.star.reflection.XCompoundTypeDescription.query(\n                  ifc);\n              ifc.delete();\n              walk(td);\n              td.delete();\n              return val;\n          }\n      case Module.uno.com.sun.star.uno.TypeClass.INTERFACE:\n          if (obj !== null) {\n              const target = obj[getProxyTarget];\n              const handle = target === undefined ? obj : target;\n              if (handle instanceof Module.ClassHandle) {\n                  if (type.toString() === 'com.sun.star.uno.XInterface') {\n                      return handle;\n                  }\n                  const embindType = 'uno_Type_' + type.toString().replace(/\\\\./g, '$');\n                  if (embindType === handle.$$.ptrType.registeredClass.name) {\n                      return handle;\n                  } else {\n                      const ifc = Module[embindType].query(handle);\n                      toDelete.push(ifc);\n                      return ifc;\n                  }\n              }\n          }\n          break;\n      }\n      return obj;\n    };\n    function translateToAny(obj, type) {\n      try {\n        let any;\n        let owning;\n        if (obj instanceof Module.uno_Any) {\n          any = obj;\n          owning = false;\n        } else {\n          let fromType;\n          let val;\n          if (type.getTypeClass() === Module.uno.com.sun.star.uno.TypeClass.ANY) {\n            fromType = getAnyType(obj);\n            if (fromType === undefined) {\n              throw new Error('bad UNO method call argument ' + obj);\n            }\n            val = fromAny(obj);\n          } else {\n            fromType = type;\n            val = obj;\n          }\n          const toDelete = [];\n          any = new Module.uno_Any(fromType, translateToEmbind(val, fromType, toDelete));\n          owning = true;\n          toDelete.forEach((val) => val.delete());\n        }\n        return {any, owning};\n      } finally {\n        type.delete();\n      }\n    };\n    function translateFromEmbind(val, type, precise, cleanUpVal) {\n      switch (type.getTypeClass()) {\n      case Module.uno.com.sun.star.uno.TypeClass.BOOLEAN:\n        return Boolean(val);\n      case Module.uno.com.sun.star.uno.TypeClass.TYPE:\n        return gcWrap(val);\n      case Module.uno.com.sun.star.uno.TypeClass.ANY:\n        {\n          const ty = gcWrap(val.getType());\n          let v;\n          try {\n            v = translateFromEmbind(val.get(), ty, precise, cleanUpVal);\n          } finally {\n            if (cleanUpVal) {\n              val.delete();\n            }\n          }\n          return precise ? new Any(ty, v) : v;\n        }\n      case Module.uno.com.sun.star.uno.TypeClass.SEQUENCE:\n        {\n          const td = type.getSequenceComponentType();\n          const arr = [];\n          for (let i = 0; i !== val.size(); ++i) {\n            arr.push(translateFromEmbind(val.get(i), td, precise, cleanUpVal));\n          }\n          if (cleanUpVal) {\n            val.delete();\n          }\n          td.delete();\n          return arr;\n        }\n      case Module.uno.com.sun.star.uno.TypeClass.STRUCT:\n      case Module.uno.com.sun.star.uno.TypeClass.EXCEPTION:\n        {\n          const obj = {\n            [Module.unoTagSymbol]: {\n              kind: type.getTypeClass()\n                == Module.uno.com.sun.star.uno.TypeClass.STRUCT\n                ? 'struct-instance' : 'exception-instance',\n              type: type.toString()\n            }\n          };\n          function walk(td) {\n            const base = td.getBaseType();\n            if (base !== null) {\n              const td = Module.uno.com.sun.star.reflection.XCompoundTypeDescription\n                .query(base);\n              base.delete();\n              walk(td);\n              td.delete();\n            }\n            const types = td.getMemberTypes();\n            const names = td.getMemberNames();\n            for (let i = 0; i !== types.size(); ++i) {\n              const name = names.get(i);\n              const td = translateTypeDescriptionAndDelete(types.get(i));\n              obj[name] = translateFromEmbind(val[name], td, precise, cleanUpVal);\n              td.delete();\n            }\n            types.delete();\n            names.delete();\n          };\n          const tdm = getTypeDescriptionManager();\n          const tdAny = tdm.getByHierarchicalName(type.toString());\n          tdm.delete();\n          const ifc = tdAny.get();\n          tdAny.delete();\n          const td = Module.uno.com.sun.star.reflection.XCompoundTypeDescription.query(\n            ifc);\n          ifc.delete();\n          walk(td);\n          td.delete();\n          return obj;\n        }\n      case Module.uno.com.sun.star.uno.TypeClass.INTERFACE:\n        return proxy(val);\n      default:\n        return val;\n      }\n    };\n    function translateFromAny(any, type, precise) {\n      if (type.getTypeClass() === Module.uno.com.sun.star.uno.TypeClass.ANY) {\n        return translateFromEmbind(any, type, precise, false);\n      } else {\n        const td = any.getType();\n        const val = translateFromEmbind(any.get(), td, precise, true);\n        td.delete();\n        return val;\n      }\n    };\n    function translateFromAnyAndDelete(any, type, precise) {\n      const val = translateFromAny(any, type, precise);\n      any.delete();\n      return val;\n    };\n    function proxy(unoObject) {\n      if (unoObject === null) {\n        return null;\n      }\n      const prox = {};\n      const toDelete = [unoObject];\n      Module.uno$zetajs_deleteRegistry.register(prox, toDelete);\n      prox[getProxyTarget] = unoObject;\n      prox.$precise = {[getProxyTarget]: unoObject, [keepAlive]: prox};\n      // css.script.XInvocation2::getInfo invents additional members (e.g., an attribute \"Foo\"\n      // if there is a method \"getFoo\"), so better determine the actual set of members via\n      // css.lang.XTypeProvider::getTypes:\n      const typeprov = Module.uno.com.sun.star.lang.XTypeProvider.query(unoObject);\n      if (typeprov !== null) {\n        const ty = Module.uno_Type.Interface('com.sun.star.uno.XInterface');\n        const arg = new Module.uno_Any(ty, unoObject);\n        ty.delete();\n        const args = new Module.uno_Sequence_any([arg]);\n        arg.delete();\n        const ctx = Module.getUnoComponentContext();\n        const serv = Module.uno.com.sun.star.script.Invocation.create(ctx);\n        ctx.delete();\n        const inst = serv.createInstanceWithArguments(args);\n        args.delete();\n        serv.delete();\n        const invoke = Module.uno.com.sun.star.script.XInvocation2.query(inst);\n        inst.delete();\n        toDelete.push(invoke);\n        function invokeMethod(name, args, precise) {\n          const info = invoke.getInfoForName(name, true);\n          try {\n            if (args.length != info.aParamTypes.size()) {\n              throw new Error(\n                'bad number of arguments in call to ' + name + ', expected ' +\n                  info.aParamTypes.size() + ' vs. actual ' + args.length);\n            }\n            const unoArgs = new Module.uno_Sequence_any(\n              info.aParamTypes.size(), Module.uno_Sequence.FromSize);\n            const deleteArgs = [];\n            for (let i = 0; i !== info.aParamTypes.size(); ++i) {\n              switch (info.aParamModes.get(i)) {\n              case Module.uno.com.sun.star.reflection.ParamMode.IN:\n                {\n                  const {any, owning} = translateToAny(\n                    args[i], info.aParamTypes.get(i));\n                  unoArgs.set(i, any);\n                  if (owning) {\n                    deleteArgs.push(any);\n                  }\n                  break;\n                }\n              case Module.uno.com.sun.star.reflection.ParamMode.INOUT:\n                {\n                  const {any, owning} = translateToAny(\n                    args[i].val, info.aParamTypes.get(i));\n                  unoArgs.set(i, any);\n                  if (owning) {\n                    deleteArgs.push(any);\n                  }\n                  break;\n                }\n              }\n            }\n            const outparamindex_out = new Module.uno_InOutParam_sequence_short;\n            const outparam_out = new Module.uno_InOutParam_sequence_any;\n            let ret;\n            try {\n              ret = invoke.invoke(name, unoArgs, outparamindex_out, outparam_out);\n            } catch (e) {\n              outparamindex_out.delete();\n              outparam_out.delete();\n              const exc = catchUnoException(e);\n              if (getAnyType(exc) ==\n                'com.sun.star.reflection.InvocationTargetException')\n              {\n                throwUnoException(exc.TargetException);\n              } else {\n                throwUnoException(exc);\n              }\n            } finally {\n              deleteArgs.forEach((arg) => arg.delete());\n              unoArgs.delete();\n            }\n            const outparamindex = outparamindex_out.val;\n            outparamindex_out.delete();\n            const outparam = outparam_out.val;\n            outparam_out.delete();\n            for (let i = 0; i !== outparamindex.size(); ++i) {\n              const j = outparamindex.get(i);\n              const ty = info.aParamTypes.get(j);\n              args[j].val = translateFromAnyAndDelete(outparam.get(i), ty, precise);\n              ty.delete();\n            }\n            outparamindex.delete();\n            outparam.delete();\n            return translateFromAnyAndDelete(ret, info.aType, precise);\n          } finally {\n            info.aType.delete();\n            info.aParamTypes.delete();\n            info.aParamModes.delete();\n          }\n        };\n        function invokeGetter(name, precise) {\n          const info = invoke.getInfoForName(name, true);\n          try {\n            const ret = invoke.getValue(name);\n            return translateFromAnyAndDelete(ret, info.aType, precise);\n          } finally {\n            info.aType.delete();\n            info.aParamTypes.delete();\n            info.aParamModes.delete();\n          }\n        };\n        function invokeSetter(name, value) {\n          const info = invoke.getInfoForName(name, true);\n          const deleteArgs = [];\n          const {any, owning} = translateToAny(value, info.aType);\n          if (owning) {\n            deleteArgs.push(any);\n          }\n          try {\n            invoke.setValue(name, any);\n          } finally {\n            // info.aType already deleted in translateToAny above\n            info.aParamTypes.delete();\n            info.aParamModes.delete();\n          }\n        };\n        prox.queryInterface = function() {\n            return invokeMethod('queryInterface', arguments, false); };\n        prox.$precise.queryInterface = function() {\n            return invokeMethod('queryInterface', arguments, true); };\n        const seen = {'com.sun.star.uno.XInterface': true};\n        function walk(td) {\n          const iname = td.getName();\n          if (!Object.hasOwn(seen, iname)) {\n            seen[iname] = true;\n            if (td.getTypeClass() !== Module.uno.com.sun.star.uno.TypeClass.INTERFACE) {\n              throw new Error('not a UNO interface type: ' + iname);\n            }\n            const itd = Module.uno.com.sun.star.reflection.XInterfaceTypeDescription2\n                .query(td);\n            const bases = itd.getBaseTypes();\n            for (let i = 0; i !== bases.size(); ++i) {\n              const base = bases.get(i);\n              walk(base);\n              base.delete();\n            }\n            bases.delete();\n            const mems = itd.getMembers();\n            for (let i = 0; i !== mems.size(); ++i) {\n              const mem = mems.get(i);\n              const name = mem.getMemberName();\n              const atd = Module.uno.com.sun.star.reflection\n                  .XInterfaceAttributeTypeDescription.query(mem);\n              mem.delete();\n              if (atd !== null) {\n                Object.defineProperty(prox, name, {\n                  enumerable: true,\n                  get() { return invokeGetter(name, false); },\n                  set: atd.isReadOnly()\n                    ? undefined\n                    : function(value) { return invokeSetter(name, value); }});\n                Object.defineProperty(prox.$precise, name, {\n                  enumerable: true,\n                  get() { return invokeGetter(name, true); },\n                  set: atd.isReadOnly()\n                    ? undefined\n                    : function(value) { return invokeSetter(name, value); }});\n                atd.delete();\n              } else {\n                prox[name] = function() { return invokeMethod(name, arguments, false); };\n                prox.$precise[name] = function() { return invokeMethod(name, arguments, true); };\n              }\n            }\n            itd.delete();\n            mems.delete();\n            if (iname === 'com.sun.star.container.XEnumeration') {\n              prox[Symbol.iterator] = function*() {\n                while (prox.hasMoreElements()) {\n                  yield prox.nextElement();\n                }\n              }\n              prox.$precise[Symbol.iterator] = function*() {\n                while (prox.$precise.hasMoreElements()) {\n                  yield prox.$precise.nextElement();\n                }\n              }\n            }\n          }\n        };\n        const tdm = getTypeDescriptionManager();\n        const types = typeprov.getTypes();\n        typeprov.delete();\n        for (let i = 0; i != types.size(); ++i) {\n          const ty = types.get(i);\n          const td = tdm.getByHierarchicalName(ty.toString());\n          ty.delete();\n          const ifc1 = td.get();\n          td.delete();\n          const ifc2 = Module.uno.com.sun.star.reflection.XTypeDescription.query(ifc1);\n          ifc1.delete();\n          walk(ifc2);\n          ifc2.delete();\n        }\n        tdm.delete();\n        types.delete();\n      }\n      return prox;\n    };\n    function singleton(name) {\n      return function(context) {\n        const any = context.getValueByName('/singletons/' + name);\n        if (getAnyType(any).getTypeClass() !==\n            Module.uno.com.sun.star.uno.TypeClass.INTERFACE\n          || any === null)\n        {\n          throwUnoException(\n            new uno.com.sun.star.uno.DeploymentException(\n              {Message: 'cannot get singeleton ' + name}));\n        }\n        return any.val;\n      };\n    };\n    function service(name, td) {\n      const obj = {};\n      const ctors = td.getConstructors();\n      for (let i = 0; i !== ctors.size(); ++i) {\n        const ctor = ctors.get(i);\n        if (ctor.isDefaultConstructor()) {\n          obj.create = function(context) {\n            const ifc = context.getServiceManager().createInstanceWithContext(\n              name, context);\n            if (ifc === null) {\n              throwUnoException(\n                new uno.com.sun.star.uno.DeploymentException(\n                  {Message:\n                   'cannot instantiate single-interface service ' + name}));\n            }\n            return ifc;\n          };\n        } else {\n          obj[ctor.getName()] = function() {\n            const context = arguments[0];\n            const args = [];\n            const params = ctor.getParameters();\n            for (let j = 0; j !== params.size(); ++j) {\n              const param = params.get(j);\n              if (param.isRestParameter()) {\n                for (; j + 1 < arguments.length; ++j) {\n                  args.push(arguments[j + 1]);\n                }\n                break;\n              } else {\n                let arg = arguments[j + 1];\n                const ty = param.getType();\n                if (ty.getTypeClass() !== Module.uno.com.sun.star.uno.TypeClass.ANY)\n                {\n                  arg = new Any(\n                    gcWrap(translateTypeDescriptionAndDelete(param.getType())),\n                    arg);\n                }\n                ty.delete();\n                args.push(arg);\n              }\n              param.delete();\n            }\n            params.delete();\n            const ifc = context.getServiceManager()\n                  .createInstanceWithArgumentsAndContext(name, args, context);\n            if (ifc === null) {\n              throwUnoException(\n                new uno.com.sun.star.uno.DeploymentException(\n                  {Message:\n                   'cannot instantiate single-interface service ' + name}));\n            }\n            return ifc;\n          };\n        }\n      }\n      ctors.delete();\n      return obj;\n    };\n    function defaultValue(type) {\n      switch (type.getTypeClass()) {\n      case Module.uno.com.sun.star.uno.TypeClass.BOOLEAN:\n        return false;\n      case Module.uno.com.sun.star.uno.TypeClass.BYTE:\n      case Module.uno.com.sun.star.uno.TypeClass.SHORT:\n      case Module.uno.com.sun.star.uno.TypeClass.UNSIGNED_SHORT:\n      case Module.uno.com.sun.star.uno.TypeClass.LONG:\n      case Module.uno.com.sun.star.uno.TypeClass.UNSIGNED_LONG:\n      case Module.uno.com.sun.star.uno.TypeClass.FLOAT:\n      case Module.uno.com.sun.star.uno.TypeClass.DOUBLE:\n        return 0;\n      case Module.uno.com.sun.star.uno.TypeClass.HYPER:\n      case Module.uno.com.sun.star.uno.TypeClass.UNSIGNED_HYPER:\n        return 0n;\n      case Module.uno.com.sun.star.uno.TypeClass.CHAR:\n        return '\\\\0';\n      case Module.uno.com.sun.star.uno.TypeClass.STRING:\n        return '';\n      case Module.uno.com.sun.star.uno.TypeClass.TYPE:\n        return Module.uno_Type.Void();\n      case Module.uno.com.sun.star.uno.TypeClass.ANY:\n        return undefined;\n      case Module.uno.com.sun.star.uno.TypeClass.SEQUENCE:\n        return [];\n      case Module.uno.com.sun.star.uno.TypeClass.ENUM:\n        {\n          const tdm = getTypeDescriptionManager();\n          const tdAny = tdm.getByHierarchicalName(type.toString());\n          tdm.delete();\n          const ifc = tdAny.get();\n          tdAny.delete();\n          const td = Module.uno.com.sun.star.reflection.XEnumTypeDescription.query(ifc);\n          ifc.delete();\n          const names = td.getEnumNames();\n          td.delete();\n          const first = names.get(0);\n          names.delete();\n          return Module['uno_Type_' + type.toString().replace(/\\\\./g, '$')][first];\n        }\n      case Module.uno.com.sun.star.uno.TypeClass.STRUCT:\n        {\n          //TODO: Make val an instanceof the corresponding struct constructor function:\n          const tdm = getTypeDescriptionManager();\n          const tdAny = tdm.getByHierarchicalName(type.toString());\n          tdm.delete();\n          const ifc = tdAny.get();\n          tdAny.delete();\n          const td = Module.uno.com.sun.star.reflection.XTypeDescription.query(ifc);\n          ifc.delete();\n          const members = {};\n          computeMembers(td, members);\n          td.delete();\n          const val = {};\n          populate(val, [], members);\n          return val;\n        }\n      case Module.uno.com.sun.star.uno.TypeClass.INTERFACE:\n        return null;\n      default:\n        throw new Error('bad member type ' + type);\n      }\n    }\n    function TypeArgumentIndex(index) { this.index = index; };\n    function computeMembers(type, obj) {\n      const td = Module.uno.com.sun.star.reflection.XCompoundTypeDescription.query(type);\n      const base = td.getBaseType();\n      if (base !== null) {\n        computeMembers(base, obj);\n        base.delete();\n      }\n      const types = td.getMemberTypes();\n      const names = td.getMemberNames();\n      td.delete();\n      for (let i = 0; i !== types.size(); ++i) {\n        const memtype = types.get(i);\n        let val;\n        if (memtype.getTypeClass() === Module.uno.com.sun.star.uno.TypeClass.UNKNOWN) {\n          const paramName = memtype.getName();\n          const std = Module.uno.com.sun.star.reflection.XStructTypeDescription.query(\n            type);\n          const params = std.getTypeParameters();\n          std.delete();\n          let index = 0;\n          for (; index !== params.size(); ++index) {\n            if (params.get(index) === paramName) {\n              break;\n            }\n          }\n          params.delete();\n          val = new TypeArgumentIndex(index);\n        } else {\n          const type = translateTypeDescription(memtype);\n          val = defaultValue(type);\n          type.delete();\n        }\n        memtype.delete();\n        obj[names.get(i)] = val;\n      }\n      types.delete();\n      names.delete();\n    };\n    function populate(obj, types, members, values) {\n      for (let i in members) {\n        let val;\n        if (values !== undefined && i in values) {\n          val = values[i];\n        } else {\n          val = members[i];\n          if (val instanceof TypeArgumentIndex) {\n            val = defaultValue(types[val.index]);\n          }\n        }\n        obj[i] = val;\n      }\n    };\n    function instantiationName(templateName, types) {\n      let name = templateName + '<';\n      for (let i = 0; i !== types.length; ++i) {\n        if (i !== 0) {\n          name += ',';\n        }\n        name += types[i];\n      }\n      return name + '>';\n    }\n    function unoidlProxy(path, embindObject) {\n      return new Proxy({}, {\n        get(target, prop) {\n          if (!Object.hasOwn(target, prop)) {\n            const name = path + '.' + prop;\n            const tdm = getTypeDescriptionManager();\n            const tdAny = tdm.getByHierarchicalName(name);\n            tdm.delete();\n            const ifc = tdAny.get();\n            tdAny.delete();\n            const td = Module.uno.com.sun.star.reflection.XTypeDescription.query(ifc);\n            ifc.delete();\n            switch (td.getTypeClass()) {\n            case Module.uno.com.sun.star.uno.TypeClass.ENUM:\n              target[prop] = embindObject[prop];\n              target[prop][Module.unoTagSymbol] = {kind: 'enum', type: name};\n              break;\n            case Module.uno.com.sun.star.uno.TypeClass.STRUCT:\n              {\n                const members = {};\n                computeMembers(td, members);\n                const std = Module.uno.com.sun.star.reflection\n                  .XStructTypeDescription.query(td);\n                const params = std.getTypeParameters();\n                std.delete();\n                const paramCount = params.size();\n                params.delete();\n                if (paramCount === 0) {\n                  target[prop] = function(values) {\n                    populate(this, [], members, values);\n                    this[Module.unoTagSymbol] = {\n                      kind: 'struct-instance', type: name};\n                  };\n                } else {\n                  target[prop] = function(types, values) {\n                    if (types.length !== paramCount) {\n                      throw new Error(\n                        'bad number of type arguments in call to ' + name +\n                          ', expected ' + paramCount + ' vs. actual ' +\n                          types.length);\n                    }\n                    populate(this, types, members, values);\n                    this[Module.unoTagSymbol] = {\n                      kind: 'struct-instance',\n                      type: instantiationName(name, types)};\n                  };\n                }\n                target[prop][Module.unoTagSymbol] = {kind: 'struct', type: name};\n                break;\n              }\n            case Module.uno.com.sun.star.uno.TypeClass.EXCEPTION:\n              {\n                const members = {};\n                computeMembers(td, members);\n                target[prop] = function(values) {\n                  populate(this, [], members, values);\n                  this[Module.unoTagSymbol] = {\n                    kind: 'exception-instance', type: name};\n                };\n                target[prop][Module.unoTagSymbol] = {kind: 'exception', type: name};\n                break;\n              }\n            case Module.uno.com.sun.star.uno.TypeClass.INTERFACE:\n              target[prop] = {[Module.unoTagSymbol]: {kind: 'interface', type: name}};\n              break;\n            case Module.uno.com.sun.star.uno.TypeClass.MODULE:\n              target[prop] = unoidlProxy(name, embindObject[prop]);\n              break;\n            case Module.uno.com.sun.star.uno.TypeClass.SINGLETON:\n              target[prop] = singleton(name);\n              break;\n            case Module.uno.com.sun.star.uno.TypeClass.SERVICE:\n              {\n                const std = Module.uno.com.sun.star.reflection\n                  .XServiceTypeDescription2.query(td);\n                if (std.isSingleInterfaceBased()) {\n                  target[prop] = service(name, std);\n                }\n                std.delete();\n                break;\n              }\n            case Module.uno.com.sun.star.uno.TypeClass.CONSTANTS:\n              target[prop] = embindObject[prop];\n              break;\n            }\n            td.delete();\n          }\n          return target[prop];\n        }\n      });\n    };\n    function Any(type, val) {\n      this.type = type;\n      this.val = val;\n    };\n    function getAnyType(val) {\n      switch (typeof val) {\n      case 'undefined':\n        return gcWrap(Module.uno_Type.Void());\n      case 'boolean':\n        return gcWrap(Module.uno_Type.Boolean());\n      case 'number':\n        return gcWrap(\n          Number.isInteger(val) && val >= -0x80000000 && val < 0x80000000\n            ? Module.uno_Type.Long()\n            : Number.isInteger(val) && val >= 0 && val < 0x100000000\n            ? Module.uno_Type.UnsignedLong()\n            : Module.uno_Type.Double());\n      case 'bigint':\n        return gcWrap(\n          val < 0x8000000000000000n\n            ? Module.uno_Type.Hyper() : Module.uno_Type.UnsignedHyper());\n      case 'string':\n        return gcWrap(Module.uno_Type.String());\n      case 'object':\n        if (val === null || Object.hasOwn(val, getProxyTarget)) {\n          return gcWrap(Module.uno_Type.Interface('com.sun.star.uno.XInterface'));\n        } else if (val instanceof Module.uno_Type) {\n          return gcWrap(Module.uno_Type.Type());\n        } else if (val instanceof Any) {\n          return val.type;\n        } else if (val instanceof Array) {\n          const t = Module.uno_Type.Any();\n          try {\n            return gcWrap(Module.uno_Type.Sequence(t));\n          } finally {\n            t.delete();\n          }\n        } else {\n          const tag = val[Module.unoTagSymbol];\n          if (tag !== undefined) {\n            if (tag.kind === 'enumerator') {\n              return gcWrap(Module.uno_Type.Enum(tag.type));\n            } else if (tag.kind === 'struct-instance') {\n              return gcWrap(Module.uno_Type.Struct(tag.type));\n            } else if (tag.kind === 'exception-instance') {\n              return gcWrap(Module.uno_Type.Exception(tag.type));\n            }\n          }\n        }\n        // fallthrough\n      default:\n        return undefined;\n      }\n    };\n    function fromAny(val) { return val instanceof Any ? val.val : val; };\n    function throwUnoException(exception) {\n      const type = gcWrap(Module.uno_Type.Exception(exception[Module.unoTagSymbol].type));\n      const toDelete = [];\n      const val = translateToEmbind(exception, type, toDelete);\n      Module.throwUnoException(type, val, toDelete);\n    };\n    function catchUnoException(exception) {\n        const td = Module.uno_Type.Any();\n        try {\n          return translateFromAnyAndDelete(Module.catchUnoException(exception), td);\n        } finally {\n          td.delete();\n        }\n    };\n    const uno = new Proxy({}, {\n      get(target, prop) {\n        if (!Object.hasOwn(target, prop)) {\n          const tdm = getTypeDescriptionManager();\n          const td = tdm.getByHierarchicalName(prop);\n          tdm.delete();\n          td.delete();\n          target[prop] = unoidlProxy(prop, Module.uno[prop]);\n        }\n        return target[prop];\n      }\n    });\n    const zetajs = {\n      type: {\n        void: gcWrap(Module.uno_Type.Void()),\n        boolean: gcWrap(Module.uno_Type.Boolean()),\n        byte: gcWrap(Module.uno_Type.Byte()),\n        short: gcWrap(Module.uno_Type.Short()),\n        unsigned_short: gcWrap(Module.uno_Type.UnsignedShort()),\n        long: gcWrap(Module.uno_Type.Long()),\n        unsigned_long: gcWrap(Module.uno_Type.UnsignedLong()),\n        hyper: gcWrap(Module.uno_Type.Hyper()),\n        unsigned_hyper: gcWrap(Module.uno_Type.UnsignedHyper()),\n        float: gcWrap(Module.uno_Type.Float()),\n        double: gcWrap(Module.uno_Type.Double()),\n        char: gcWrap(Module.uno_Type.Char()),\n        string: gcWrap(Module.uno_Type.String()),\n        type: gcWrap(Module.uno_Type.Type()),\n        any: gcWrap(Module.uno_Type.Any()),\n        sequence(type) { return gcWrap(Module.uno_Type.Sequence(type)); },\n        enum(name) {\n          if (typeof name === 'function' && Object.hasOwn(name, Module.unoTagSymbol)\n            && name[Module.unoTagSymbol].kind === 'enum')\n          {\n            name = name[Module.unoTagSymbol].type;\n          }\n          return gcWrap(Module.uno_Type.Enum(name));\n        },\n        struct(name) {\n          if (typeof name === 'function' && Object.hasOwn(name, Module.unoTagSymbol)\n            && name[Module.unoTagSymbol].kind === 'struct')\n          {\n            name = name[Module.unoTagSymbol].type;\n          }\n          return gcWrap(Module.uno_Type.Struct(name));\n        },\n        exception(name) {\n          if (typeof name === 'function' && Object.hasOwn(name, Module.unoTagSymbol)\n            && name[Module.unoTagSymbol].kind === 'exception')\n          {\n            name = name[Module.unoTagSymbol].type;\n          }\n          return gcWrap(Module.uno_Type.Exception(name));\n        },\n        interface(name) {\n          if (typeof name === 'object' && Object.hasOwn(name, Module.unoTagSymbol)\n            && name[Module.unoTagSymbol].kind === 'interface')\n          {\n            name = name[Module.unoTagSymbol].type;\n          }\n          return gcWrap(Module.uno_Type.Interface(name));\n        }\n      },\n      Any,\n      getAnyType,\n      fromAny,\n      sameUnoObject: function(obj1, obj2) {\n        const type = Module.uno_Type.Interface('com.sun.star.uno.XInterface');\n        const toDelete = [];\n        try {\n          return Module.sameUnoObject(\n            translateToEmbind(obj1, type, toDelete),\n            translateToEmbind(obj2, type, toDelete));\n        } finally {\n          type.delete();\n          toDelete.forEach((val) => val.delete());\n        }\n      },\n      getUnoComponentContext: function() {\n        return proxy(Module.getUnoComponentContext());\n      },\n      throwUnoException,\n      catchUnoException,\n      uno,\n      unoObject: function(interfaces, obj) {\n        const wrapper = {};\n        const toDelete = [];\n        Module.uno$zetajs_deleteRegistry.register(wrapper, toDelete);\n        const seen = {\n          'com.sun.star.lang.XTypeProvider': true, 'com.sun.star.uno.XInterface': true};\n        function walk(td) {\n          const iname = td.getName();\n          if (!Object.hasOwn(seen, iname)) {\n            seen[iname] = true;\n            if (td.getTypeClass() !== Module.uno.com.sun.star.uno.TypeClass.INTERFACE) {\n              throw new Error('not a UNO interface type: ' + iname);\n            }\n            const itd = Module.uno.com.sun.star.reflection.XInterfaceTypeDescription2\n                  .query(td);\n            const bases = itd.getBaseTypes();\n            for (let i = 0; i !== bases.size(); ++i) {\n              const base = bases.get(i);\n              walk(base);\n              base.delete();\n            }\n            bases.delete();\n            const mems = itd.getMembers();\n            itd.delete();\n            for (let i = 0; i !== mems.size(); ++i) {\n              const ifc = mems.get(i);\n              const atd = Module.uno.com.sun.star.reflection\n                .XInterfaceAttributeTypeDescription.query(ifc);\n              ifc.delete();\n              if (atd !== null) {\n                const aname = atd.getMemberName();\n                const type = translateTypeDescriptionAndDelete(atd.getType());\n                toDelete.push(type);\n                wrapper['get' + aname] = function() {\n                  return translateToEmbind(\n                    obj['get' + aname].apply(obj), type, []);\n                };\n                if (!atd.isReadOnly()) {\n                  wrapper['set' + aname] = function() {\n                    obj['set' + aname].apply(\n                      obj, [translateFromEmbind(arguments[0], type, true, false)]);\n                  };\n                }\n                atd.delete();\n              } else {\n                const ifc = mems.get(i);\n                const mtd = Module.uno.com.sun.star.reflection\n                  .XInterfaceMethodTypeDescription.query(ifc);\n                ifc.delete();\n                const mname = mtd.getMemberName();\n                const retType = translateTypeDescriptionAndDelete(\n                  mtd.getReturnType());\n                toDelete.push(retType);\n                const params = [];\n                const descrs = mtd.getParameters();\n                mtd.delete();\n                for (let j = 0; j !== descrs.size(); ++j) {\n                  const descr = descrs.get(j);\n                  const type = translateTypeDescriptionAndDelete(descr.getType());\n                  toDelete.push(type);\n                  params.push({type, dirIn: descr.isIn(), dirOut: descr.isOut()});\n                  descr.delete();\n                }\n                descrs.delete();\n                wrapper[mname] = function() {\n                  const args = [];\n                  for (let i = 0; i !== params.length; ++i) {\n                    let arg;\n                    if (params[i].dirOut) {\n                      arg = {};\n                      if (params[i].dirIn) {\n                        arg.val = translateFromEmbind(\n                          arguments[i].val, params[i].type, true, false);\n                      }\n                    } else {\n                      arg = translateFromEmbind(\n                        arguments[i], params[i].type, true, false);\n                    }\n                    args.push(arg);\n                  }\n                  const ret = translateToEmbind(\n                    obj[mname].apply(obj, args), retType, []);\n                  for (let i = 0; i !== params.length; ++i) {\n                    if (params[i].dirOut) {\n                      arguments[i].val = translateToEmbind(\n                        args[i].val, params[i].type, []);\n                    }\n                  }\n                  return ret;\n                };\n              }\n            }\n            mems.delete();\n          }\n        };\n        const tdm = getTypeDescriptionManager();\n        const interfaceNames = [];\n        interfaces.forEach((i) => {\n          let name = i;\n          if (typeof name === 'object' && Object.hasOwn(name, Module.unoTagSymbol)\n              && name[Module.unoTagSymbol].kind === 'interface')\n          {\n              name = name[Module.unoTagSymbol].type;\n          } else if (name instanceof Module.uno_Type\n                     && (name.getTypeClass()\n                         === Module.uno.com.sun.star.uno.TypeClass.INTERFACE))\n          {\n            name = name.toString();\n          }\n          interfaceNames.push(name);\n          const tdAny = tdm.getByHierarchicalName(name);\n          const ifc = tdAny.get();\n          const td = Module.uno.com.sun.star.reflection.XTypeDescription.query(ifc);\n          ifc.delete();\n          walk(td);\n          td.delete();\n        })\n        tdm.delete();\n        return proxy(Module.unoObject(interfaceNames, wrapper));\n      },\n      mainPort: Module.uno_mainPort\n    };\n    resolve(zetajs);\n  };\n  Module.zetajs$reject = reject;\n});\n\nModule.uno_init.then(function() { Module.zetajs$resolve(); });\n\n/* vim:set shiftwidth=2 softtabstop=2 expandtab cinoptions=b1,g0,N-s cinkeys+=0=break: */`;\n\n/**\n * zetaHelper.js content from zetajs library\n * This file provides helper functions for main thread and worker thread coordination\n */\nexport const ZETA_HELPER_JS_CONTENT = `// ATTENTION: Experimental code! Expect heavy API changes.\n/**\n * Helper for code in the browsers main thread.\n * @beta\n */\nexport class ZetaHelperMain {\n    /**\n     * Use absolute URLs or URLs relative to the root HTML document (location.href).\n     * @param threadJs - URL for JS code file running inside the office thread (web worker).\n     * @param options.threadJsType - 'classic' or 'module' (ES2015)\n     *   see: https://developer.mozilla.org/docs/Web/API/Worker/Worker#type\n     * @param options.wasmPkg - Which WASM binaries to use. Possible options:\n     *   'free', 'business', 'url:YOUR_CUSTOM_URL'\n     * @param options.blockPageScroll - Don't scroll the HTML page while the cursor is above\n     *   the canvas. (default: true)\n     */\n    constructor(threadJs, options) {\n        this.threadJsType = 'classic';\n        // Enable usage of LOWA builds with UI.\n        const canvas = document.getElementById('qtcanvas');\n        const thisFileUrl = import.meta.url;\n        const modUrlDir = thisFileUrl.substring(0, thisFileUrl.length - 'zetaHelper.js'.length);\n        if (threadJs)\n            threadJs = (new URL(threadJs, location.href)).toString();\n        const zetajsScript = modUrlDir + 'zeta.js';\n        const threadWrapScript = 'data:text/javascript;charset=UTF-8,' +\n            'import(\"' + import.meta.url + '\").then(m => {m.zetaHelperWrapThread();});';\n        const wasmPkg = options.wasmPkg || 'free';\n        let soffice_base_url = ZetaHelperMain.wasmUrls[wasmPkg] || ZetaHelperMain.wasmUrls['free'];\n        if (wasmPkg?.substring(0, 4) === 'url:')\n            soffice_base_url = wasmPkg.substring(4, wasmPkg.length);\n        if (soffice_base_url === '')\n            soffice_base_url = './';\n        soffice_base_url = (new URL(soffice_base_url, location.href)).toString();\n        const Module = {\n            canvas,\n            uno_scripts: [zetajsScript, threadWrapScript],\n            locateFile: (path, prefix) => { return (prefix || soffice_base_url) + path; },\n            modUrlDir,\n        };\n        Module.mainScriptUrlOrBlob = new Blob([\"importScripts('\" + (new URL('soffice.js', soffice_base_url)) + \"');\"], { type: 'text/javascript' });\n        let lastDevicePixelRatio = window.devicePixelRatio;\n        addEventListener('resize', () => {\n            // Workaround to inform Qt5 about changed browser zoom.\n            setTimeout(() => {\n                if (lastDevicePixelRatio != -1) {\n                    if (lastDevicePixelRatio != window.devicePixelRatio) {\n                        lastDevicePixelRatio = -1;\n                        this.widthPxAdd(canvas.style, +1);\n                        window.dispatchEvent(new Event('resize'));\n                    }\n                }\n                else {\n                    lastDevicePixelRatio = window.devicePixelRatio;\n                    this.widthPxAdd(canvas.style, -1);\n                    window.dispatchEvent(new Event('resize'));\n                }\n            }, 100);\n        });\n        // Scroll only the canvas while the mouse cursor is above it.\n        if (options.blockPageScroll != false)\n            canvas.addEventListener('wheel', (event) => {\n                event.preventDefault();\n            }, { passive: false });\n        window.Module = Module; // window.* is global\n        this.canvas = canvas;\n        this.Module = Module;\n        this.threadJs = threadJs?.toString() || null;\n        if (options.threadJsType === 'module')\n            this.threadJsType = 'module';\n        this.soffice_base_url = soffice_base_url;\n    }\n    start(app_init) {\n        const zHM = this;\n        const soffice_js = document.createElement(\"script\");\n        soffice_js.src = zHM.soffice_base_url + \"soffice.js\";\n        // \"onload\" runs after the loaded script has run.\n        soffice_js.onload = () => {\n            console.log('zetaHelper: Configuring Module');\n            zHM.Module.uno_main.then((pThrPort) => {\n                zHM.thrPort = pThrPort;\n                zHM.FS = window.FS;\n                zHM.thrPort.onmessage = (e) => {\n                    switch (e.data.cmd) {\n                        case 'ZetaHelper::thr_started':\n                            // Trigger resize of the embedded window to match the canvas size.\n                            // May somewhen be obsoleted by:\n                            //   https://gerrit.libreoffice.org/c/core/+/174040\n                            window.dispatchEvent(new Event('resize'));\n                            zHM.thrPort.postMessage({\n                                cmd: 'ZetaHelper::run_thr_script',\n                                threadJs: zHM.threadJs,\n                                threadJsType: zHM.threadJsType\n                            });\n                            app_init();\n                            break;\n                        default:\n                            throw Error('Unknown message command: ' + e.data.cmd);\n                    }\n                    ;\n                };\n            });\n        };\n        console.log('zetaHelper: Loading WASM binaries for ZetaJS from: ' + zHM.soffice_base_url);\n        // Hint: The global objects \"canvas\" and \"Module\" must exist before the next line.\n        document.body.appendChild(soffice_js);\n    }\n    widthPxAdd(obj, value) {\n        if (/\\\\A\\\\d+px\\\\z/.test(obj.width)) {\n            obj.width = parseInt(obj.width) + value + 'px';\n        }\n    }\n}\nZetaHelperMain.wasmUrls = {\n    free: 'https://cdn.zetaoffice.net/zetaoffice_latest/',\n    business: 'https://business-cdn.zetaoffice.net/zetaoffice_latest/',\n};\n/**\n * Initializes zetajs in the office thread (web worker).\n * Will be called by ZetaHelperMain.\n * NOT MEANT FOR DIRECT USE\n * @beta\n */\nexport function zetaHelperWrapThread() {\n    const zJsModule = globalThis.Module;\n    zJsModule.zetajs.then((zetajs) => {\n        const port = zetajs.mainPort;\n        port.onmessage = (e) => {\n            switch (e.data.cmd) {\n                case 'ZetaHelper::run_thr_script':\n                    port.onmessage = null;\n                    globalThis.zetajsStore = { zetajs, zJsModule };\n                    let threadJs = e.data.threadJs;\n                    if (threadJs) {\n                        if (e.data.threadJsType === 'module') {\n                            console.log('zetaHelper: Loading threadJs as module from: ' + threadJs);\n                            import(threadJs).then(module => {\n                                // Make exports of threadJs accessible for debugging.\n                                globalThis.zetajsStore.threadJsContext = module;\n                            });\n                        }\n                        else { // classic\n                            console.log('zetaHelper: Loading threadJs as script from: ' + threadJs);\n                            importScripts(threadJs);\n                        }\n                    }\n                    else {\n                        console.log('zetaHelper: Office loaded. No threadJs given.');\n                    }\n                    break;\n                default:\n                    throw Error('Unknown message command: ' + e.data.cmd);\n            }\n            ;\n        };\n        port.postMessage({\n            cmd: 'ZetaHelper::thr_started'\n        });\n    });\n}\n/**\n * Helper for inside the office thread (web worker).\n * @beta\n */\nexport class ZetaHelperThread {\n    constructor() {\n        this.zetajs = globalThis.zetajsStore.zetajs;\n        this.zJsModule = globalThis.zetajsStore.zJsModule;\n        this.thrPort = this.zetajs.mainPort;\n        this.css = this.zetajs.uno.com.sun.star;\n        this.context = this.zetajs.getUnoComponentContext();\n        this.desktop = this.css.frame.Desktop.create(this.context);\n        this.config = this.css.configuration.ReadWriteAccess.create(this.context, 'en-US');\n    }\n    /**\n     * Turn off toolbars.\n     * @param officeModules - [\"Base\", \"Calc\", \"Draw\", \"Impress\", \"Math\", \"Writer\"];\n     */\n    configDisableToolbars(officeModules) {\n        for (const mod of officeModules) {\n            const modName = \"/org.openoffice.Office.UI.\" + mod + \"WindowState/UIElements/States\";\n            const uielems = this.config.getByHierarchicalName(modName);\n            for (const i of uielems.getElementNames()) {\n                if (i.startsWith(\"private:resource/toolbar/\")) {\n                    const uielem = uielems.getByName(i); // SLOW OPERATION\n                    if (uielem.getByName('Visible')) {\n                        uielem.setPropertyValue('Visible', false);\n                    }\n                }\n            }\n        }\n        this.config.commitChanges();\n    }\n    /**\n     * @param unoUrl - string following \".uno:\" (e.g. \"Bold\")\n     */\n    transformUrl(unoUrl) {\n        const ioparam = { val: new this.css.util.URL({ Complete: '.uno:' + unoUrl }) };\n        this.css.util.URLTransformer.create(this.context).parseStrict(ioparam);\n        return ioparam.val;\n    }\n    queryDispatch(ctrl, urlObj) {\n        return ctrl.queryDispatch(urlObj, '_self', 0);\n    }\n    dispatch(ctrl, unoUrl, params = []) {\n        const urlObj = this.transformUrl(unoUrl);\n        this.queryDispatch(ctrl, urlObj).dispatch(urlObj, params);\n    }\n}`;\n\n/**\n * Create a blob URL for zeta.js content\n * Cached after first call\n */\nexport function createZetaJsBlobUrl(): string {\n  if (!zetaJsBlobUrl) {\n    const blob = new Blob([ZETA_JS_CONTENT], { type: \"application/javascript\" });\n    zetaJsBlobUrl = URL.createObjectURL(blob);\n  }\n  return zetaJsBlobUrl;\n}\n\n/**\n * Create a blob URL for zetaHelper.js content\n * Cached after first call\n */\nexport function createZetaHelperJsBlobUrl(): string {\n  if (!zetaHelperJsBlobUrl) {\n    const blob = new Blob([ZETA_HELPER_JS_CONTENT], { type: \"application/javascript\" });\n    zetaHelperJsBlobUrl = URL.createObjectURL(blob);\n  }\n  return zetaHelperJsBlobUrl;\n}\n\n/**\n * Clean up blob URLs (call when done with PDF export functionality)\n * Note: Usually not needed as blob URLs are tied to document lifetime\n */\nexport function cleanupBlobUrls(): void {\n  if (zetaJsBlobUrl) {\n    URL.revokeObjectURL(zetaJsBlobUrl);\n    zetaJsBlobUrl = null;\n  }\n  if (zetaHelperJsBlobUrl) {\n    URL.revokeObjectURL(zetaHelperJsBlobUrl);\n    zetaHelperJsBlobUrl = null;\n  }\n}\n\n"]}